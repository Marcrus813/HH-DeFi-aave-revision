const { swapWeth, SUPPLY_AMOUNT } = require("./getWeth");
const { paramConfig } = require("../configs/params-config");
const { getContractFromLocalAbi } = require("../utils/contractParser");
const { ethers } = require("hardhat");
const ABI_HOME = "../abis/";

async function aaveBorrow() {
    await swapWeth();
    const availableAccounts = await ethers.getSigners();
    const [deployer] = availableAccounts;
    const pool = await getLendingPool(deployer);
    const poolAddress = await pool.getAddress();
    console.log(`Pool address: ${poolAddress}`);

    // Approve the pool to spend WETH
    await approveErc20(poolAddress, SUPPLY_AMOUNT, deployer);

    // Supply(Deposit)
    await supplyWeth(pool, deployer);

    // Get user data
    let { totalDebtBase, availableBorrowsBase } = await getUserData(
        pool,
        deployer,
    );
    // Get DAI conversion rate
    const latestEthPriceUsd = await getPrice("ETH/USD");

    const availableBorrowInEth = availableBorrowsBase / latestEthPriceUsd; // 8
    const limitedBorrowAmountEth = Number(availableBorrowInEth) * 0.95;
    const limitedBorrowAmountWei = ethers.parseEther(
        limitedBorrowAmountEth.toString(),
    );

    const daiWeiPrice = await getPrice("DAI/ETH");
    const daiAmount = Number(limitedBorrowAmountWei) / Number(daiWeiPrice);
    console.log(`Borrowing DAI: ${daiAmount}`);
    const daiAmountWei = ethers.parseEther(daiAmount.toString());
}

async function getWethContract(account) {
    const wethContract = await getContractFromLocalAbi(
        paramConfig.wEthParam.mainnet.wEthAddress,
        ABI_HOME + "WETH.json",
        account,
    );
    return wethContract;
}

async function getLendingPool(account) {
    const poolAddressesProvider = await getContractFromLocalAbi(
        paramConfig.aave.mainnet.lendingPoolProviderAddress,
        ABI_HOME + "PoolAddressesProvider.json",
        account,
    );
    const poolAddress = await poolAddressesProvider.getPool();
    /**
     * The address is a proxy which points to an actual logic contract, we need to interact with the logic
     * contract, hence we need the ABI of the logic contract, the abi we have: `Pool.json` is the ABI of the
     * proxy, so here we are using the ABI generated by hardhat, the contract interface is from `@aave/core-v3`
     */
    /* const pool = await getContract( // Old code, won't work
        poolAddress,
        ABI_HOME + "Pool.json",
        account,
    ); */
    const pool = await ethers.getContractAt("IPool", poolAddress, account);
    return pool;
}

async function approveErc20(spender, amount, account) {
    const weth = await getWethContract(account);
    const approveTxn = await weth.approve(spender, amount);
    await approveTxn.wait(1);
    console.log(`Approved spender: ${spender}`);
}

async function supplyWeth(poolContract, deployer) {
    console.log("Supplying WETH to Aave");

    const supplyTxn = await poolContract.supply(
        paramConfig.wEthParam.mainnet.wEthAddress, // asset
        SUPPLY_AMOUNT, // amount
        deployer.address, // onBehalfOf
        0, // referralCode? see note
    );
    await supplyTxn.wait(1);
    console.log(
        `Supply successful, amount: ${ethers.formatEther(SUPPLY_AMOUNT)}`,
    );
}

async function getUserData(pool, account) {
    const userDataStruct = await pool.getUserAccountData(account.address);
    const {
        totalCollateralBase,
        totalDebtBase,
        availableBorrowsBase,
        currentLiquidationThreshold,
        ltv,
        healthFactor,
    } = userDataStruct;
    console.log(
        `Account: ${account.address}-Total collateral: ${totalCollateralBase}`,
    );
    console.log(`Account: ${account.address}-Total debt: ${totalDebtBase}`);
    console.log(
        `Account: ${account.address}-Available borrow: ${availableBorrowsBase}`,
    );
    console.log(
        `Account: ${account.address}-Current liquidation threshold: ${currentLiquidationThreshold}`,
    );
    console.log(`Account: ${account.address}-Loan to value: ${ltv}`);
    console.log(`Account: ${account.address}-Health factor: ${healthFactor}`);
    return {
        totalCollateralBase, // USD * 10 ** 8
        totalDebtBase,
        availableBorrowsBase,
        currentLiquidationThreshold,
        ltv,
        healthFactor,
    };
}

/**
 *
 * @param {string} pair "DAI/ETH", "ETH/USD"
 * @returns {BigInt} Answer
 */
async function getPrice(pair) {
    let priceFeedAddress;
    if (pair === "ETH/USD") {
        priceFeedAddress = paramConfig.aave.mainnet.ethUsdPriceFeedAddress;
    } else if (pair === "DAI/ETH") {
        priceFeedAddress = paramConfig.aave.mainnet.daiEthPriceFeedAddress;
    }
    const priceFeed = await ethers.getContractAt(
        "AggregatorV3Interface",
        priceFeedAddress,
    );
    const { answer } = await priceFeed.latestRoundData();
    return answer;
}

async function borrowDai() {}

async function main() {
    await aaveBorrow();
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

module.exports = { aaveBorrow };
